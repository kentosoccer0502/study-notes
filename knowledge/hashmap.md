```plain
┌────────────┐
│  キー: "Alice"  │
└────────────┘
         │
         ▼
┌─────────────────────┐
│ ハッシュ関数 h("Alice") = 3456789 │  ← 文字列を数値に変換
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│ 3456789 % 10 = 9             │  ← 0〜9 の範囲に収める（配列サイズ m = 10）
└─────────────────────┘
         │
         ▼
┌─────────────────────┐
│ 配列インデックス 9 に保存        │
└─────────────────────┘
```

いいですね 👍
では次は、**「衝突（collision）」が起きたときの仕組み**を図で説明します。

---

## 💥 衝突とは？

ハッシュ関数の結果が **違うキーでも同じインデックス** になってしまうことです。

---

### 🧭 例（図）

```
キー: "Alice" → h("Alice") = 3456789 → 3456789 % 10 = 9
キー: "Bob"   → h("Bob")   = 7891239 → 7891239 % 10 = 9
```

どちらも `% 10` の結果が **9** になる！

---

### ⚙️ 配列の状態（衝突が起きた）

```
配列（サイズ m = 10）

インデックス:  0   1   2   3   4   5   6   7   8    9
内容:          -   -   -   -   -   -   -   -   -  [???]
                                           ↑
                              ここに "Alice" と "Bob" が両方来た！
```

---

## 🔗 解決法 1：チェイン法（chaining）

各スロット（配列のマス）に「**リスト（または Linked List）**」を置く方法です。

```
配列[9] → [("Alice", 95) → ("Bob", 87)]
```

図にすると：

```
配列の中身：

インデックス:   内容
───────────────
0〜8           -
9              ┌────────────┐
               │ ("Alice",95)│
               │ ("Bob",87)  │ ← 衝突したデータをリストでつなげる
               └────────────┘
```

これなら、同じインデックスに複数の要素を保持できます。

---

## ⚡ 取り出すとき

1. 「Bob」を探したい
2. `h("Bob") % 10 = 9`
3. 配列[9] のリストを順に探す
4. `"Bob"` を見つけて値（87）を返す

平均的にはリストが短いので、O(1) で高速に動きます。

---

## 🧠 まとめ

| 仕組み     | 目的                                  |
| ---------- | ------------------------------------- |
| `% m`      | 配列の範囲に収める                    |
| チェイン法 | 衝突したデータをリストでまとめる      |
| 結果       | 高速アクセス (平均 O(1)) が可能になる |

---

希望があれば、もう一つの衝突処理法（**オープンアドレス法**）も図付きで解説できます。
やってみますか？
